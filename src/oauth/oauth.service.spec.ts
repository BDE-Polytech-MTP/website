import { Test, TestingModule } from '@nestjs/testing';
import { OAuthService } from './oauth.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ResourceOwner } from '../models/resource-owner.entity';
import { OAuthClient } from '../models/oauth-client.entity';
import { OAuthAuthorizationCode } from '../models/oauth-authorization-code.entity';
import { PasswordService } from '../password/password.service';
import { ConfigService } from '@nestjs/config';
import { OAuthToken } from '../models/oauth-token.entity';
import { Repository } from 'typeorm';
import { BadRequestException } from '@nestjs/common';
import { mockRepository } from '../testing/utils';

describe('OauthService', () => {
  let service: OAuthService;
  let oauthCodeRepository: Repository<OAuthAuthorizationCode>;
  let oauthTokenRepository: Repository<OAuthToken>;
  let resourceOwnerRepository: Repository<ResourceOwner>;
  let passwordService: PasswordService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        OAuthService,
        PasswordService,
        mockRepository(ResourceOwner),
        mockRepository(OAuthClient),
        mockRepository(OAuthAuthorizationCode),
        mockRepository(OAuthToken),
        {
          provide: ConfigService,
          useValue: { get: () => 'secret_key' },
        },
      ],
    }).compile();

    service = module.get<OAuthService>(OAuthService);
    oauthCodeRepository = module.get(
      getRepositoryToken(OAuthAuthorizationCode),
    );
    oauthTokenRepository = module.get(getRepositoryToken(OAuthToken));
    resourceOwnerRepository = module.get(getRepositoryToken(ResourceOwner));
    passwordService = module.get(PasswordService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('generateTokenFromAuthorizationCode', () => {
    it('should throw BadRequestException when given code does not exist', () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(() => undefined);

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should remove existing token if code has already been used then throw BadRequestException', async () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.hasAlreadyBeenUsed = () => true;
          code.hasBeenGeneratedBy = () => true;
          code.isExpired = () => false;
          return code;
        });
      const deleteSpy = jest.spyOn(oauthTokenRepository, 'delete');

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      await expect(result).rejects.toThrow(BadRequestException);
      expect(deleteSpy).toHaveBeenCalled();
    });

    it('should throw BadRequestException if code is expired', () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.isExpired = () => true;
          code.hasAlreadyBeenUsed = () => false;
          code.hasBeenGeneratedBy = () => true;
          return code;
        });

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException is code has not been generated by the given client', () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.hasAlreadyBeenUsed = () => false;
          code.hasBeenGeneratedBy = () => false;
          code.isExpired = () => false;
          return code;
        });

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should return access_token and refresh_token when client is valid and code valid', async (done) => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.issuedAt = new Date();
          code.hasAlreadyBeenUsed = () => false;
          code.hasBeenGeneratedBy = () => true;
          code.isExpired = () => false;
          return code;
        });

      const result = await service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      expect(result).toBeTruthy();
      expect(result.access_token).toBeTruthy();
      expect(result.refresh_token).toBeTruthy();
      done();
    });
  });

  describe('generateTokenFromCredentials', () => {
    it('should throw BadRequestException when user do not exists', () => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(() => undefined);

      const result = service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException when user password do not match', () => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(async () => new ResourceOwner());
      jest
        .spyOn(passwordService, 'checkPassword')
        .mockImplementation(async () => false);

      const result = service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException when user do not have password', () => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(async () => {
          const user = new ResourceOwner();
          user.password = null;
          return user;
        });

      const result = service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should resolve if password is valid', async (done) => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(async () => new ResourceOwner());
      jest
        .spyOn(passwordService, 'checkPassword')
        .mockImplementation(async () => true);

      const result = await service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      expect(result).toBeTruthy();
      expect(result.access_token).toBeTruthy();
      expect(result.refresh_token).toBeTruthy();
      done();
    });
  });

  describe('decodeBasicAuth', () => {
    it('should decode correctly the basic token', () => {
      const buffer = Buffer.from('username:password')
      const token = buffer.toString('base64');
      const result = service.decodeBasicAuth(`Basic ${token}`);

      expect(result.client_id).toBe('username');
      expect(result.client_secret).toBe('password');
    });
  });
});
