import { Test, TestingModule } from '@nestjs/testing';
import { OAuthService } from './oauth.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ResourceOwner } from '../models/resource-owner.entity';
import { OAuthClient } from '../models/oauth-client.entity';
import { OAuthAuthorizationCode } from '../models/oauth-authorization-code.entity';
import { PasswordService } from '../password/password.service';
import { ConfigService } from '@nestjs/config';
import { OAuthToken } from '../models/oauth-token.entity';
import { Repository } from 'typeorm';
import { BadRequestException } from '@nestjs/common';
import { mockRepository } from '../../test/mock/utils';
import * as moment from 'moment';

describe('OauthService', () => {
  let service: OAuthService;
  let oauthCodeRepository: Repository<OAuthAuthorizationCode>;
  let oauthTokenRepository: Repository<OAuthToken>;
  let resourceOwnerRepository: Repository<ResourceOwner>;
  let passwordService: PasswordService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        OAuthService,
        PasswordService,
        mockRepository(ResourceOwner),
        mockRepository(OAuthClient),
        mockRepository(OAuthAuthorizationCode),
        mockRepository(OAuthToken),
        {
          provide: ConfigService,
          useValue: { get: () => 'secret_key' },
        },
      ],
    }).compile();

    service = module.get<OAuthService>(OAuthService);
    oauthCodeRepository = module.get(
      getRepositoryToken(OAuthAuthorizationCode),
    );
    oauthTokenRepository = module.get(getRepositoryToken(OAuthToken));
    resourceOwnerRepository = module.get(getRepositoryToken(ResourceOwner));
    passwordService = module.get(PasswordService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('generateTokenFromAuthorizationCode', () => {
    it('should throw BadRequestException when given code does not exist', () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(() => undefined);

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should remove existing token if code has already been used then throw BadRequestException', async () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.hasAlreadyBeenUsed = () => true;
          code.hasBeenGeneratedBy = () => true;
          code.isExpired = () => false;
          return code;
        });
      const deleteSpy = jest.spyOn(oauthTokenRepository, 'delete');

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      await expect(result).rejects.toThrow(BadRequestException);
      expect(deleteSpy).toHaveBeenCalled();
    });

    it('should throw BadRequestException if code is expired', () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.isExpired = () => true;
          code.hasAlreadyBeenUsed = () => false;
          code.hasBeenGeneratedBy = () => true;
          return code;
        });

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException is code has not been generated by the given client', () => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.hasAlreadyBeenUsed = () => false;
          code.hasBeenGeneratedBy = () => false;
          code.isExpired = () => false;
          return code;
        });

      const result = service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should return access_token and refresh_token when client is valid and code valid', async (done) => {
      jest
        .spyOn(oauthCodeRepository, 'findOne')
        .mockImplementation(async () => {
          const code = new OAuthAuthorizationCode();
          code.issuedAt = new Date();
          code.hasAlreadyBeenUsed = () => false;
          code.hasBeenGeneratedBy = () => true;
          code.isExpired = () => false;
          code.resourceOwner = new ResourceOwner();
          code.resourceOwner.id = 'ro-uuid';
          return code;
        });

      const result = await service.generateTokenFromAuthorizationCode({
        code: 'code',
        client_id: 'client_id',
        client_secret: 'client_secret',
      });

      expect(result).toBeTruthy();
      expect(result.access_token).toBeTruthy();
      expect(result.refresh_token).toBeTruthy();
      done();
    });
  });

  describe('generateTokenFromCredentials', () => {
    it('should throw BadRequestException when user do not exists', () => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(() => undefined);

      const result = service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should returns lowercase email when calling findOne', () => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(async (cond: any) => {
          if (cond.where[0].email === 'lowercase') {
            const ro = new ResourceOwner();
            ro.id = 'ro-uuid';
            ro.password = 'password';
            return ro;
          }
          return undefined;
        });
      jest
        .spyOn(passwordService, 'checkPassword')
        .mockImplementation(async () => true);

      const result = service.generateTokenFromCredentials({
        username: 'LowerCase',
        password: 'password ',
      });

      return expect(result).resolves.toBeTruthy();
    });

    it('should throw BadRequestException when user password do not match', () => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(async () => {
          const ro = new ResourceOwner();
          ro.password = 'other password';
          return ro;
        });
      jest
        .spyOn(passwordService, 'checkPassword')
        .mockImplementation(async () => false);

      const result = service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException when user do not have password', () => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(async () => {
          const user = new ResourceOwner();
          user.password = null;
          return user;
        });

      const result = service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      return expect(result).rejects.toThrow(BadRequestException);
    });

    it('should resolve if password is valid', async (done) => {
      jest
        .spyOn(resourceOwnerRepository, 'findOne')
        .mockImplementation(async () => {
          const ro = new ResourceOwner();
          ro.id = 'ro-uuid';
          return ro;
        });
      jest
        .spyOn(passwordService, 'checkPassword')
        .mockImplementation(async () => true);

      const result = await service.generateTokenFromCredentials({
        username: 'username',
        password: 'password',
      });

      expect(result).toBeTruthy();
      expect(result.access_token).toBeTruthy();
      expect(result.refresh_token).toBeTruthy();
      done();
    });
  });

  describe('decodeBasicAuth', () => {
    it('should decode correctly the basic token', () => {
      const buffer = Buffer.from('username:password');
      const token = buffer.toString('base64');
      const result = service.decodeBasicAuth(`Basic ${token}`);

      expect(result.client_id).toBe('username');
      expect(result.client_secret).toBe('password');
    });
  });

  describe('resourceOwnerFromBearerToken', () => {
    it('should return null if bearer token is not known', () => {
      jest
        .spyOn(oauthTokenRepository, 'findOne')
        .mockImplementation(async () => undefined);

      const result = service.resourceOwnerFromBearerToken(
        'Bearer 54df5sdq45qsfd54sd',
      );

      return expect(result).resolves.toBeNull();
    });

    it('should return null if bearer token is expired', () => {
      jest
        .spyOn(oauthTokenRepository, 'findOne')
        .mockImplementation(async () => {
          const token = new OAuthToken();
          token.expiresAt = moment().subtract(1, 'd').toDate();
          token.resourceOwner = new ResourceOwner();
          return token;
        });

      const result = service.resourceOwnerFromBearerToken('Bearer fdsdffdsfsd');

      return expect(result).resolves.toBeNull();
    });

    it('should return scopes and resource owner if token is valid', async () => {
      jest
        .spyOn(oauthTokenRepository, 'findOne')
        .mockImplementation(async () => {
          const token = new OAuthToken();
          token.expiresAt = moment().add(1, 'd').toDate();
          token.resourceOwner = new ResourceOwner();
          token.scopes = ['all'];
          return token;
        });

      const result = await service.resourceOwnerFromBearerToken(
        'Bearer sfd645fds',
      );

      expect(result).not.toBeNull();
      expect(result).toHaveProperty('resourceOwner');
      expect(result).toHaveProperty('scopes', ['all']);
    });
  });
});
